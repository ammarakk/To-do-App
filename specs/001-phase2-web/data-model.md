# Data Model: Phase 2 - Multi-User Web Application

**Feature**: 001-phase2-web
**Date**: 2026-01-17
**Status**: Final

## Overview

This document defines the database schema, entity relationships, validation rules, and state transitions for Phase 2. The data model enforces strict user isolation through Row Level Security (RLS) and supports all CRUD operations with search, filter, and pagination capabilities.

---

## Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         auth.users (Supabase Auth)                  │
│ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌───────────┐│
│ │ id (UUID)    │  │ email        │  │ password     │  │ ...       ││
│ │ (PK)         │  │ (unique)     │  │ (hashed)     │  │           ││
│ └──────────────┘  └──────────────┘  └──────────────┘  └───────────┘│
│                                │                                    │
│                                │ 1:N                                │
│                                ▼                                    │
│ ┌─────────────────────────────────────────────────────────────────┐│
│ │                            todos                                 ││
│ │ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           ││
│ │ │ id (UUID)    │  │ user_id      │  │ title        │           ││
│ │ │ (PK)         │  │ (FK)         │  │ (TEXT)       │           ││
│ │ ├──────────────┤  ├──────────────┤  ├──────────────┤           ││
│ │ │ description  │  │ is_completed │  │ priority     │           ││
│ │ │ (TEXT)       │  │ (BOOLEAN)    │  │ (TEXT)       │           ││
│ │ ├──────────────┤  ├──────────────┤  ├──────────────┤           ││
│ │ │ due_date     │  │ category     │  │ created_at   │           ││
│ │ │ (TIMESTAMPTZ)│  │ (TEXT)       │  │ (TIMESTAMPTZ)│           ││
│ │ ├──────────────┤  └──────────────┘  └──────────────┘           ││
│ │ │ updated_at   │                                                ││
│ │ │ (TIMESTAMPTZ)│                                                ││
│ │ └──────────────┘                                                ││
│ └─────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
```

---

## Entity Definitions

### 1. User (managed by Supabase Auth)

**Table**: `auth.users` (Supabase managed table)

**Description**: Represents a user account with authentication credentials. Managed entirely by Supabase Auth—no direct SQL modifications allowed.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Unique user identifier (auto-generated by Supabase) |
| `email` | TEXT | UNIQUE, NOT NULL | User's email address (used for login) |
| `encrypted_password` | TEXT | NOT NULL | Hashed password (managed by Supabase) |
| `email_confirmed_at` | TIMESTAMPTZ | nullable | Timestamp when email was confirmed |
| `created_at` | TIMESTAMPTZ | DEFAULT now() | Account creation timestamp |
| `updated_at` | TIMESTAMPTZ | DEFAULT now() | Last update timestamp |
| `raw_app_meta_data` | JSONB | nullable | Application metadata (extensible) |
| `raw_user_meta_data` | JSONB | nullable | User profile metadata (extensible) |

**Relationships**:
- **One-to-Many with Todos**: One user can have multiple todos

**Validation Rules**:
- Email must be valid format (enforced by Supabase)
- Password must meet Supabase default requirements (min 8 characters)
- Email must be unique across all users

**Access Control**:
- Users can only modify their own profile via Supabase Auth API
- No direct SQL INSERT/UPDATE/DELETE on `auth.users` (use Supabase Auth API)

---

### 2. Todo

**Table**: `public.todos`

**Description**: Represents a task item owned by a specific user. All CRUD operations enforce strict user isolation via RLS policies.

**Attributes**:

| Field | Type | Constraints | Default | Description |
|-------|------|-------------|---------|-------------|
| `id` | UUID | PRIMARY KEY | uuid_generate_v4() | Unique todo identifier |
| `user_id` | UUID | FOREIGN KEY → auth.users(id), NOT NULL | - | Owner of the todo (enforced by RLS) |
| `title` | TEXT | NOT NULL, CHECK (length >= 1 and length <= 200) | - | Todo title (required, 1-200 chars) |
| `description` | TEXT | nullable | - | Detailed description (optional) |
| `is_completed` | BOOLEAN | NOT NULL | false | Completion status |
| `priority` | TEXT | NOT NULL, CHECK (priority IN ('low', 'medium', 'high')) | 'medium' | Priority level |
| `due_date` | TIMESTAMPTZ | nullable | - | Optional due date with timezone |
| `category` | TEXT | nullable | - | Category/tag for organization |
| `created_at` | TIMESTAMPTZ | NOT NULL | now() | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | NOT NULL | now() | Last update timestamp |

**Relationships**:
- **Many-to-One with User**: Each todo belongs to exactly one user

**Validation Rules**:
1. **Title**: Must be 1-200 characters (non-empty after trimming)
2. **Priority**: Must be one of: 'low', 'medium', 'high'
3. **Due Date**: If provided, must be a valid ISO 8601 timestamp
4. **User ID**: Must match authenticated user's ID (enforced by RLS)
5. **Created/Updated**: Automatically managed by database triggers

**Indexes** (for query performance):

```sql
CREATE INDEX idx_todos_user_id ON todos(user_id);
CREATE INDEX idx_todos_user_completed ON todos(user_id, is_completed);
CREATE INDEX idx_todos_priority ON todos(user_id, priority);
CREATE INDEX idx_todos_due_date ON todos(user_id, due_date);
CREATE INDEX idx_todos_category ON todos(user_id, category);
CREATE INDEX idx_todos_created_at ON todos(user_id, created_at DESC);
```

**Triggers**:

```sql
-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_todos_updated_at
    BEFORE UPDATE ON todos
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## Row Level Security (RLS) Policies

### Enable RLS

```sql
ALTER TABLE todos ENABLE ROW LEVEL SECURITY;
```

### Policy Definitions

| Policy Name | Operation | Using Clause | Check Clause | Description |
|-------------|-----------|--------------|--------------|-------------|
| `Users can view own todos` | SELECT | `auth.uid() = user_id` | - | Users can only read their own todos |
| `Users can insert own todos` | INSERT | - | `auth.uid() = user_id` | Users can only create todos with their own user_id |
| `Users can update own todos` | UPDATE | `auth.uid() = user_id` | - | Users can only update their own todos |
| `Users can delete own todos` | DELETE | `auth.uid() = user_id` | - | Users can only delete their own todos |

### SQL Implementation

```sql
-- SELECT Policy
CREATE POLICY "Users can view own todos"
ON todos FOR SELECT
USING (auth.uid() = user_id);

-- INSERT Policy
CREATE POLICY "Users can insert own todos"
ON todos FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- UPDATE Policy
CREATE POLICY "Users can update own todos"
ON todos FOR UPDATE
USING (auth.uid() = user_id);

-- DELETE Policy
CREATE POLICY "Users can delete own todos"
ON todos FOR DELETE
USING (auth.uid() = user_id);
```

**Security Note**: RLS policies are enforced at the database level. Even if the API layer is compromised, users cannot access other users' data.

---

## State Transitions

### Todo Lifecycle

```
┌─────────────────────────────────────────────────────────────────────┐
│                          Todo State Machine                         │
└─────────────────────────────────────────────────────────────────────┘

     ┌──────────────┐
     │   CREATED    │  ◄─── Initial state when todo is created
     │ is_completed │
     │  = false     │
     └──────┬───────┘
            │
            │ User marks as complete
            │ (PUT /api/todos/{id} with is_completed=true)
            ▼
     ┌──────────────┐
     │  COMPLETED   │  ◄─── Todo is done
     │ is_completed │
     │  = true      │
     └──────┬───────┘
            │
            │ User marks as incomplete
            │ (PUT /api/todos/{id} with is_completed=false)
            ▼
     ┌──────────────┐
     │   CREATED    │  ◄─── Back to active state
     └──────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                         DELETE EVENT                                 │
│                                                                      │
│  User deletes todo (DELETE /api/todos/{id})                         │
│                  │                                                   │
│                  ▼                                                   │
│  ┌──────────────────┐                                               │
│  │    DELETED       │  ◄─── Todo is permanently removed            │
│  │  (no longer      │       from database (cascade delete not       │
│  │   accessible)    │       needed—todos are independent)          │
│  └──────────────────┘                                               │
└─────────────────────────────────────────────────────────────────────┘
```

### User Authentication State

```
┌─────────────────────────────────────────────────────────────────────┐
│                        User Auth State Machine                       │
└─────────────────────────────────────────────────────────────────────┘

     ┌──────────────┐
     │   UNKNOWN    │  ◄─── Initial state (not logged in)
     └──────┬───────┘
            │
            │ User signs up (POST /api/auth/signup)
            │ User logs in (POST /api/auth/login)
            ▼
     ┌──────────────┐
     │ AUTHENTICATED│  ◄─── User has valid JWT token
     │    (JWT      │        Token stored in localStorage
     │   valid)     │        Token attached to API requests
     └──────┬───────┘
            │
            │ User logs out (POST /api/auth/logout)
            │ Token expires (after 1 hour by default)
            ▼
     ┌──────────────┐
     │   UNKNOWN    │  ◄─── Redirect to login page
     └──────────────┘
```

---

## Data Access Patterns

### 1. Create Todo

**SQL Query**:
```sql
INSERT INTO todos (user_id, title, description, priority, due_date, category)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING *;
```

**Parameters**:
- `$1`: user_id (extracted from JWT)
- `$2`: title
- `$3`: description (optional)
- `$4`: priority (default: 'medium')
- `$5`: due_date (optional)
- `$6`: category (optional)

**RLS Enforcement**: INSERT policy ensures `user_id` matches `auth.uid()`

---

### 2. Read Todos (with pagination and filters)

**SQL Query**:
```sql
SELECT *
FROM todos
WHERE user_id = $1
  AND ($2::text IS NULL OR title ILIKE '%' || $2 || '%' OR description ILIKE '%' || $2 || '%')
  AND ($3::text IS NULL OR priority = $3)
  AND ($4::boolean IS NULL OR is_completed = $4)
  AND ($5::text IS NULL OR category = $5)
ORDER BY
  CASE
    WHEN priority = 'high' THEN 1
    WHEN priority = 'medium' THEN 2
    WHEN priority = 'low' THEN 3
  END,
  created_at DESC
LIMIT $6 OFFSET $7;
```

**Parameters**:
- `$1`: user_id (from JWT)
- `$2`: search_query (optional)
- `$3`: priority_filter (optional)
- `$4`: is_completed_filter (optional)
- `$5`: category_filter (optional)
- `$6`: limit (default: 20)
- `$7`: offset (for pagination)

**RLS Enforcement**: SELECT policy ensures only user's own todos are returned

---

### 3. Update Todo

**SQL Query**:
```sql
UPDATE todos
SET
  title = COALESCE($2, title),
  description = COALESCE($3, description),
  is_completed = COALESCE($4, is_completed),
  priority = COALESCE($5, priority),
  due_date = COALESCE($6, due_date),
  category = COALESCE($7, category)
WHERE id = $1 AND user_id = $8
RETURNING *;
```

**Parameters**:
- `$1`: todo_id
- `$2`: new_title (optional)
- `$3`: new_description (optional)
- `$4`: new_is_completed (optional)
- `$5`: new_priority (optional)
- `$6`: new_due_date (optional)
- `$7`: new_category (optional)
- `$8`: user_id (from JWT)

**RLS Enforcement**: UPDATE policy ensures user can only update their own todos

---

### 4. Delete Todo

**SQL Query**:
```sql
DELETE FROM todos
WHERE id = $1 AND user_id = $2
RETURNING *;
```

**Parameters**:
- `$1`: todo_id
- `$2`: user_id (from JWT)

**RLS Enforcement**: DELETE policy ensures user can only delete their own todos

---

## Validation Rules Summary

### Backend Validation (FastAPI + Pydantic)

**TodoCreate Schema**:
```python
class TodoCreate(BaseModel):
    title: str = Field(min_length=1, max_length=200)
    description: str | None = Field(None, max_length=2000)
    priority: Literal['low', 'medium', 'high'] = 'medium'
    due_date: datetime | None = None
    category: str | None = Field(None, max_length=50)
```

**TodoUpdate Schema**:
```python
class TodoUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = Field(None, max_length=2000)
    is_completed: bool | None = None
    priority: Literal['low', 'medium', 'high'] | None = None
    due_date: datetime | None = None
    category: str | None = Field(None, max_length=50)
```

### Frontend Validation (React Hook Form / Zod)

**Todo Form Schema**:
```typescript
const todoSchema = z.object({
  title: z.string().min(1, "Title is required").max(200, "Title too long"),
  description: z.string().max(2000, "Description too long").optional(),
  priority: z.enum(['low', 'medium', 'high']).default('medium'),
  due_date: z.string().datetime().optional(),
  category: z.string().max(50, "Category too long").optional(),
});
```

---

## Migration Script

**File**: `backend/migrations/001_create_todos_table.sql`

```sql
-- Create todos table
CREATE TABLE IF NOT EXISTS todos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL CHECK (char_length(title) >= 1 AND char_length(title) <= 200),
    description TEXT,
    is_completed BOOLEAN NOT NULL DEFAULT false,
    priority TEXT NOT NULL DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),
    due_date TIMESTAMPTZ,
    category TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_todos_user_id ON todos(user_id);
CREATE INDEX IF NOT EXISTS idx_todos_user_completed ON todos(user_id, is_completed);
CREATE INDEX IF NOT EXISTS idx_todos_priority ON todos(user_id, priority);
CREATE INDEX IF NOT EXISTS idx_todos_due_date ON todos(user_id, due_date);
CREATE INDEX IF NOT EXISTS idx_todos_category ON todos(user_id, category);
CREATE INDEX IF NOT EXISTS idx_todos_created_at ON todos(user_id, created_at DESC);

-- Create trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS update_todos_updated_at ON todos;
CREATE TRIGGER update_todos_updated_at
    BEFORE UPDATE ON todos
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE todos ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
DROP POLICY IF EXISTS "Users can view own todos" ON todos;
CREATE POLICY "Users can view own todos"
ON todos FOR SELECT
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own todos" ON todos;
CREATE POLICY "Users can insert own todos"
ON todos FOR INSERT
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own todos" ON todos;
CREATE POLICY "Users can update own todos"
ON todos FOR UPDATE
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own todos" ON todos;
CREATE POLICY "Users can delete own todos"
ON todos FOR DELETE
USING (auth.uid() = user_id);
```

---

## Summary

The data model enforces strict user isolation through Row Level Security (RLS), supports all CRUD operations with comprehensive validation, and includes performance optimizations through strategic indexing. All access patterns filter by `user_id` extracted from the JWT token, ensuring users can only access their own data at both the API and database layers.

**Key Features**:
- ✅ Strict user data isolation (RLS + API-level filtering)
- ✅ Comprehensive validation (backend + frontend)
- ✅ Performance optimization (indexes on all filterable fields)
- ✅ Automatic timestamp management (created_at, updated_at)
- ✅ State machine for todo lifecycle and user authentication
- ✅ Migration script for reproducible database setup

**Next**: Generate API contracts in `contracts/openapi.yaml`
